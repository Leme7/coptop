#!/usr/bin/env php
<?php
// Author:   Charles Thompson <01charles.t@gmail.com>
// Created:  July 06, 2015
// Purpose:  Monitor MySQL's processlist with some administrative features
// GitHub:   https://github.com/vuther/coptop

//////////////////////////////////
//       Defaults Settings      //
//////////////////////////////////
$version = "v1.0";
$config  = array(
	'user'         => '',
	'password'     => '',
	'server'       => '',
	'port'         => 3306,
	'header'       => 1,
	'delay'        => 1,
	'show_idle'    => 0,
	'reverse_sort' => 1,
	'resolve_ip'   => 1,
	'ansi_refresh' => 0,
	'user_filter'  => '',
	'db_filter'    => '',
	'host_filter'  => '',
	'time_filter'  => 0,
);

//////////////////////////////////
//        ANSI Characters       //
//////////////////////////////////
$CSI        = "\e[";
$RESET      = $CSI . "0m";
$RED        = $CSI . "0;31m";
$GREEN      = $CSI . "0;32m";
$YELLOW     = $CSI . "0;33m";
$MAGENTA    = $CSI . "0;35m";
$CYAN       = $CSI . "0;36m";
$BOLD_CYAN  = $CSI . "1;36m";
$BOLD       = $CSI . "1m";
$UNDERLINE  = $CSI . "4m";
$ansi_chars = array(
	'CURSOR_TO_START' => $CSI . "H",    # Start the cursor 
	'EEL'             => $CSI . "K",    # Erase end of line
	'EEB'             => $CSI . "J",    # Erase down
	'HIDE_CURSOR'     => $CSI . "?25l", # Hide cursor
	'SHOW_CURSOR'     => $CSI . "?25h"  # Show cursor
);   

//////////////////////////////////
//   Check required functions   //
//////////////////////////////////
if (!function_exists('mysqli_connect')) {
	exit($RED . "You do not have mysqli installed. Install it via apt-get install php5-mysqlnd$RESET\n");
}
if (!function_exists('readline_callback_handler_install')) {
	exit($RED . "Your PHP version was not compiled with readline! It has to be compiled " . 
				"with readline for coptop to work.$RESET\n");
}

//////////////////////////////////
//   Command line parameters    //
//////////////////////////////////
$opts = getopt('u:p:h:P:', array('delay:', 'idle:', 'sort:', 'resolve:', 'ansi:', 'header:', 'help', 'prompt'));
if (isset($opts['help'])) helpme('--help');

// Use my.cnf client's information if available
if (isset($_SERVER['HOME']) && file_exists($_SERVER['HOME'] . "/.my.cnf")) {
	$mycnf = parse_ini_file($_SERVER['HOME'] . "/.my.cnf", true);

	if (isset($mycnf['client']['user']) && !isset($opts['u'])) {
		$config['user'] = $mycnf['client']['user'];
	}
	if (isset($mycnf['client']['password']) && !isset($opts['p']) && !isset($opts['prompt'])) {
		$config['password'] = $mycnf['client']['password'];
	}
}

// Check to make sure these variables have values
if (!isset($opts['u']) && !isset($mycnf['client']['user'])) {
	exit($RED . "You did not enter a username! Use --help parameter if you need assistance.\n");
}
if (!isset($opts['p']) && !isset($opts['prompt']) && !isset($mycnf['client']['password'])) {
	exit($RED . "You did not enter a password! Use --help parameter if you need assistance.\n");
}
if (!isset($opts['h'])) {
	exit($RED . "You did not enter a host! Use --help parameter if you need assistance.\n");
}

// Set config variables if they're used in command line
if (isset($opts['u']))       $config['user']         = $opts['u'];
if (isset($opts['p']))       $config['password']     = $opts['p'];
if (isset($opts['P']))       $config['port']         = $opts['P'];
if (isset($opts['h']))       $config['server']       = $opts['h'];
if (isset($opts['header']))  $config['header']       = $opts['header'];
if (isset($opts['delay']))   $config['delay']        = $opts['delay'];
if (isset($opts['idle']))    $config['show_idle']    = $opts['idle'];
if (isset($opts['sort']))    $config['reverse_sort'] = $opts['sort'];
if (isset($opts['resolve'])) $config['resolve_ip']   = $opts['resolve'];
if (isset($opts['ansi']))    $config['ansi_refresh'] = $opts['ansi'];

// Get password to server privately
if (isset($opts['prompt'])) {
	print($CYAN . "Password: $RESET");
	system('stty -echo');
	$config['password'] = trim(fgets(STDIN));
	system('stty echo');
	echo "\n";
}

// Loop timings
$key_press_delay    = 10;
$delay_microseconds = 100 * 1000;

//////////////////////////////////
//     Connect to database      //
//////////////////////////////////
$connection = new mysqli($config['server'], $config['user'], $config['password'], '', $config['port']);
 
if ($connection->connect_error) {
	trigger_error($RED . "Database connection failed: " . $connection->connect_error, E_USER_ERROR);
}

//////////////////////////////////
//    MySQL Server variables    //
//////////////////////////////////
$variables             = execute_query('SHOW GLOBAL VARIABLES', 1);
$short_version         = substr($variables['version'], 0, 3);
$use_processlist_query = 0;

// Determine if processlist query should be used based on mysql version
if ($short_version == '5.0' || $short_version == '5.1') {
	$use_processlist_query = 1;
}

// Get proper server version fork
if (strpos(strtolower($variables['version_comment']), 'mariadb cluster') !== false) {
	$db_fork = 'MariaDB Cluster';
} else if (strpos(strtolower($variables['version_comment']), 'mariadb') !== false) {
	$db_fork = 'MariaDB';
} else if (strpos(strtolower($variables['version_comment']), 'percona xtradb cluster') !== false) {
	$db_fork = 'Percona XtraDB Cluster';
} else if (strpos(strtolower($variables['version_comment']), 'percona server') !== false) {
	$db_fork = 'Percona Server';
} else {
	$db_fork = 'MySQL';
	$use_processlist_query = 1; # Regular MySQL doesn't have TIME_MS field in PROCESSLIST table
}

// Get version without the garbage at the end
$db_version = explode('-', $variables['version'])[0];

// Clear screen and create some variables
system('clear');
$status         = array();
$servers_slaved = array();
//////////////////////////////////
//          Main Loop           //
//////////////////////////////////
while (1) {
	$thread_data = array();

	// Height & Width of terminal
	$cols  = exec('tput cols');
	$lines = exec('tput lines');

	// Find out how many lines we have use
	$lines_left = $lines - 1;

	// ANSI characters for smoother refresh
	if ($config['ansi_refresh']) {
		print($ansi_chars['EEL']);
	} else {
		system('clear'); // Clear screen
	}
	print($ansi_chars['HIDE_CURSOR']);

	// Save old status data
	$old_status = $status;

	// Get our statuses in arrays
	$status        = execute_query('SHOW GLOBAL STATUS', 1);
	$master_status = execute_query('SHOW MASTER STATUS', 2);
	$slave_status  = execute_query('SHOW SLAVE STATUS', 2);

	//////////////////////////////////
	//    Calculations for Header   //
	//////////////////////////////////

	// Uptime of server
	$dtF    = new DateTime("@0");
	$dtT    = new DateTime("@" . $status['Uptime']);
	$uptime = $dtF->diff($dtT)->format('%a days, %h hours, %i minutes and %s seconds');

	// Calculate DML Queries Per Second
	if (isset($old_status['Queries'])) {
		$selects_per_sec = $status['Com_select'] - $old_status['Com_select'];
		$updates_per_sec = $status['Com_update'] - $old_status['Com_update'];
		$inserts_per_sec = $status['Com_insert'] - $old_status['Com_insert'];
		$deletes_per_sec = $status['Com_delete'] - $old_status['Com_delete'];
	} else {
		$selects_per_sec = 0;
		$updates_per_sec = 0;
		$inserts_per_sec = 0;
		$deletes_per_sec = 0;
	}

	# MyISAM Efficiency
	if ($status['Key_reads'] && $status['Key_read_requests']) {
		$myisam_hit_rate = sprintf("%.2f%%", (100 - ($status['Key_reads'] / $status['Key_read_requests']) * 100));
	} else {
		$myisam_hit_rate = "N/A";
	}

	# InnoDB Efficiency
	if ($status['Innodb_buffer_pool_read_requests'] && $status['Innodb_buffer_pool_reads']) {
		$innodb_hit_rate = sprintf("%.2f%%", (100 - ($status['Innodb_buffer_pool_reads'] / ($status['Innodb_buffer_pool_read_requests'])) * 100));
	} else {
		$innodb_hit_rate = "N/A";
	}

	# Calculate tmp tables per second
	if (isset($old_status['Created_tmp_disk_tables'])) {
		$tmp_tables_per_sec      = $status['Created_tmp_tables']      - $old_status['Created_tmp_tables'];
		$tmp_disk_tables_per_sec = $status['Created_tmp_disk_tables'] - $old_status['Created_tmp_disk_tables'];
	} else {
		$tmp_tables_per_sec      = 0;
		$tmp_disk_tables_per_sec = 0;
	}

	if ($config['delay'] == 1) {
		$tmp_tables_memory = "$RESET($CYAN$tmp_tables_per_sec/s$RESET)";
		$tmp_tables_disk   = "$RESET($CYAN$tmp_disk_tables_per_sec/s$RESET)";
	}

	//////////////////////////////////
	//     Print Header Section     //
	//////////////////////////////////
	if ($config['header']) {
		$help_section = $cols - 20;
		$repeat_char  = str_repeat(" ", $cols);

		if ($config['ansi_refresh']) print($ansi_chars['CURSOR_TO_START']);
		printf("%-$help_section" . "s", "Monitoring database server$MAGENTA " . $config['server'] . $RESET . " ($db_fork v$db_version)");
		print("$BOLD_CYAN coptop $version$RESET - Press ? for help$RESET\n");
		printf("%-18s %s", "MySQL Uptime", "$CYAN$uptime$RESET\n");

		if ($config['delay'] == 1) {
			printf("%-18s %s", "Query Analytics", "Selects: $CYAN$selects_per_sec" . "/s$RESET, Updates: $CYAN$updates_per_sec/s$RESET, " . 
												  "Deletes: $CYAN$deletes_per_sec" . "/s$RESET, Inserts: $CYAN$inserts_per_sec/s$RESET\n");
			$lines_left--;
		}

		print(sprintf("%-31s", "\nInnoDB Efficiency: $RESET$CYAN") . sprintf("%-9s", $innodb_hit_rate) . "$RESET" . 
			  sprintf("%-28s", "Open Tables: $RESET$CYAN") . sprintf("%-9s", $status['Open_tables']) . "$RESET" . 
			  sprintf("%-32s", "Aborted Clients: $RESET$CYAN") . sprintf("%-9s", $status['Aborted_clients']) . "$RESET\n");

		print(sprintf("%-30s", "MyISAM Efficiency: $RESET$CYAN") . sprintf("%-9s", $myisam_hit_rate) . "$RESET" . 
			  sprintf("%-28s", "Opened Tables: $RESET$CYAN") . sprintf("%-9s", $status['Opened_tables']) . "$RESET" . 
			  sprintf("%-26s", "Aborted Connections: $RESET$CYAN") . sprintf("%-9s", $status['Aborted_connects']) . "$RESET\n");

		print(sprintf("%-30s", "Threads Connected: $RESET$CYAN") . sprintf("%-9s", $status['Threads_connected']) . "$RESET" . 
			  sprintf("%-28s", "Threads Created: $RESET$CYAN") . sprintf("%-9s", $status['Threads_created']) . "$RESET" . 
			  sprintf("%-32s", "Tmp Tables Memory: $RESET$CYAN") . sprintf("%-10s", $status['Created_tmp_tables']) . 
			  "$RESET$tmp_tables_memory\n");

		print(sprintf("%-30s", "Threads Running: $RESET$CYAN") . sprintf("%-9s", $status['Threads_running']) . "$RESET" . 
			  sprintf("%-28s", "Threads Cached: $RESET$CYAN") . sprintf("%-9s", $status['Threads_cached']) . "$RESET" . 
			  sprintf("%-32s", "Tmp Tables Disk: $RESET$CYAN") . sprintf("%-10s", $status['Created_tmp_disk_tables']) . 
			  "$RESET$tmp_tables_disk\n");

		if ($slave_status) {
			if ($config['resolve_ip']) {
				if (filter_var($slave_status['Master_Host'] , FILTER_VALIDATE_IP)) {
					$slave_status['Master_Host'] = explode('.', gethostbyaddr($slave_status['Master_Host']))[0];
				} else {
					$slave_status['Master_Host'] = explode('.', $slave_status['Master_Host'])[0];
				}
			} else {
				if (!filter_var($slave_status['Master_Host'] , FILTER_VALIDATE_IP)) {
					$slave_status['Master_Host'] = gethostbyname($slave_status['Master_Host']);
				}
			}

			print("\n");
			print(sprintf("%-30s", "Slave IO: $RESET$CYAN") . sprintf("%-9s", $slave_status['Slave_IO_Running']) . "$RESET" . "Reading Log:    " .
				"$RESET$CYAN " . $slave_status['Master_Log_File'] . "$RESET (position: $CYAN" . $slave_status['Exec_Master_Log_Pos'] . "$RESET)\n");
			print(sprintf("%-30s", "Slave SQL: $RESET$CYAN") .  sprintf("%-9s", $slave_status['Slave_SQL_Running']) . "$RESET" . "Seconds Behind:  " .
				"$RESET$CYAN" . $slave_status['Seconds_Behind_Master'] . "$RESET\n");
			print("Slaved to Master:  $RESET$CYAN" . $slave_status['Master_Host'] . "$RESET\n");
			$lines_left -= 4;
		}

		if ($master_status) {
			print("\nMaster Binary Log: $CYAN" . $master_status['File'] . "$RESET (position: $CYAN" . $master_status['Position'] . "$RESET)\n");
			$lines_left -= 2;

			if ($servers_slaved) {
				print("Slave Server(s):   $CYAN" .  implode(", ", $servers_slaved) . "\n");
				$lines_left--;
			}
		}

		print("$CYAN$UNDERLINE$repeat_char$RESET\n\n");
		$lines_left -= 9;
	} else {
		if ($config['ansi_refresh']) print($ansi_chars['CURSOR_TO_START']);
	}

	//////////////////////////////////
	//  Processlist Thread Section  //
	//////////////////////////////////
	if ($use_processlist_query) {
		$pl_sql = "SHOW FULL PROCESSLIST";
	} else {
		$pl_sql = "SELECT Id, User, Host, db, Command, Host, Time_MS As Time, Info, State FROM information_schema.PROCESSLIST";
	}
	$data = execute_query($pl_sql, 3);
 
	// Put threads from processlist into array
	foreach ($data as $row) {
		// Host/IP format
		$row['Host']     = explode(":", $row['Host'])[0]; // Remove port from hostname/IP
		$thread_using_ip = 0;

		if (filter_var($row['Host'], FILTER_VALIDATE_IP)) {
			$thread_using_ip = 1;
		}
		if ($config['resolve_ip']) {
			if ($thread_using_ip) {
				$row['Host'] = gethostbyaddr($row['Host']);
			}
			if (!filter_var($row['Host'], FILTER_VALIDATE_IP)) {
				$row['Host'] = explode(".", $row['Host'])[0];
			}
		} else {
			if (!$thread_using_ip) {
				$row['Host'] = gethostbyname($row['Host']);
			}
		}

		// Save slave servers to array
		$servers_slaved = array(); // Reset it
		if ($row['Command'] == 'Binlog Dump') $servers_slaved[] = $row['Host'];

		// Remove newline chars
		$row['Info'] = trim(preg_replace('/\s+/', ' ', $row['Info']));

		// Save thread data to array
		$thread_data[$row['Id']] = array(
			"user"    => $row['User'],    "host" => $row['Host'], "db"   => $row['db'], 
			"command" => $row['Command'], "time" => $row['Time'], "info" => $row['Info'],
			"state"   => $row['State']
		);
	}

	// This is to show sleeping threads if there's not a lot threads when you first begin to monitor the server
	if (!isset($first_time) && sizeof($thread_data) <= 20) {
		$config['show_idle'] = 1;
		$first_time = 1;
	}

	// Sort by time
	if ($config['reverse_sort']) {
		uasort($thread_data, function($a, $b) {
			return $b['time'] - $a['time'];
		});
	} else {
		uasort($thread_data, function($a, $b) {
			return $a['time'] - $b['time'];
		});
	}

	//////////////////////////////////
	//   Print Processlist Threads  //
	//////////////////////////////////

	// Processlist header
	$free_screen = $cols - 67; // 68 is the length of our headers
	$repeat_char = str_repeat("-", $free_screen - 1);
	print($BOLD . "Identifier   Username   Hostname/IP   Database      Time   Command  Query/State\n" . $RESET);
	print($CYAN . "----------  ---------  ------------  ---------  --------  --------  $repeat_char\n" . $RESET);
	$lines_left -= 2;

	// Loop each thread
	foreach($thread_data as $id => $thread) {
		// Skip thread if these conditions are met
		if (!$lines_left) break;
		if ($thread['command'] == 'Binlog Dump' && !$config['show_idle']) continue;
		if ($thread['command'] == 'Sleep' && !$config['show_idle']) continue; 
		if ($thread['command'] == 'Connect' && $thread['state'] == 'Writing to net') continue;
		if ($thread['command'] == 'Connect' && $thread['state'] == 'Reading from net') continue;
		if ($thread['command'] == 'Connect' && $thread['state'] == 'login') continue;
		if ($thread['command'] == 'Init DB' && $thread['state'] == 'Writing to net') continue;
		if ($thread['command'] == 'Init DB' && $thread['state'] == 'init') continue;
		if ($thread['command'] == 'Statistics' && $thread['state'] == 'init') continue;
		if ($thread['command'] == 'Query' && $thread['state'] == 'init') continue;
		if ($thread['command'] == 'Query' && $thread['state'] == 'Writing to net') continue;
		if ($thread['command'] == 'Killed' && $thread['state'] == 'cleaning up') continue;
		if ($thread['command'] == 'Ping') continue;
		if ($thread['info'] == $pl_sql) continue;
		if ($thread['info'] == 'SHOW GLOBAL STATUS') continue;
		if ($config['user_filter'] && $thread['user'] != $config['user_filter']) continue;
		if ($config['db_filter']   && $thread['db']   != $config['db_filter']) continue;
		if ($config['host_filter'] && $thread['host'] != $config['host_filter']) continue;

		// Use state if there is one
		if ($thread['state'] && !$thread['info']) {
			$info = $thread['state'];
		} else {
			$info = $thread['info'];
		}

		# Get the format of thread time
		$seconds = intval($thread['time'] / 1000);
		if ($seconds >= 99999999) continue;

		if ($use_processlist_query) {
			$seconds    = $thread['time'];
			$final_time = $seconds . "s";
		} else if ($seconds >= 1) {
			$final_time = sprintf("%s", $seconds) . "s";
		} else {
			$final_time = sprintf("%d", $thread['time']) . "ms";
		}
		$thread_data[$id]['time'] = $final_time;
		if ($config['time_filter'] && $seconds <= $config['time_filter']) continue;

		// Determine thread color
		if ($thread['command']  == 'Sleep' || 
			$thread['command']  == 'Connect' || 
			$thread['command']  == "Binlog Dump") { $color = $RESET; } 
		else if ($thread['user'] == 'backup') { $color = $MAGENTA; } 
		else if ($seconds <= 0) { $color = $GREEN; } 
		else if ($seconds >= 3) { $color = $RED; } 
		else if ($seconds >= 1) { $color = $YELLOW; }

		// Print thread
		print($color);
		printf("%10d %10.9s %13.12s %10.9s %9s %9.8s %-$free_screen.$free_screen" . "s",
			   $id, $thread['user'], $thread['host'], $thread['db'],
			   $final_time, $thread['command'], " $info");
		print("$RESET\n");

		$lines_left--;
		if (!$lines_left) break;
	}

	if ($config['ansi_refresh']) print($ansi_chars['EEL'] . $ansi_chars['EEB']);
	print($ansi_chars['SHOW_CURSOR']);

	//////////////////////////////////
	//      Capture Key Press       //
	//////////////////////////////////
	$polling_delay = $config['delay'] * $key_press_delay;
	for ($x = 0; $x < $polling_delay; $x++) {
		$result = '';

		readline_callback_handler_install('', function() { });
		while (1) {
			$r = array(STDIN);
			$w = NULL;
			$e = NULL;
			$n = stream_select($r, $w, $e, 0);
			if ($n && in_array(STDIN, $r)) {
				$c = stream_get_contents(STDIN, 1);
				$result = readKey($c);
			} else {
				$result = readKey('');
			}
			break;
		}

		if ($result) break; // Break out of key press loop if a command was run
	}
}

//////////////////////////////////
//          Functions           //
//////////////////////////////////
function readKey($key) {
	global $connection, $thread_data, $config, $BOLD_CYAN, $CYAN, $RESET, $RED, $UNDERLINE, $BOLD, $delay_microseconds;
	$run_command = 0;

	switch ($key) {
		case '?': // Help
			helpme('?');

			$run_command = 1;
			break;
		case 'c': // Clear all filters
			$config['user_filter'] = '';
			$config['db_filter']   = '';
			$config['host_filter'] = '';
			$config['time_filter'] = '';

			print($CYAN . "Cleared all filters!$RESET");
			sleep(1);

			$run_command = 1;
			break;
		case 'd': // Filter by database
			$input = read_stdin("Database to filter by: ");
			$config['db_filter'] = $input;

			$run_command = 1;
			break;
		case 'D': // Show available databases
			system('clear');

			print("$CYAN$UNDERLINE" . "Available Databases$RESET\n");
			$results = execute_query("SHOW DATABASES", 3);

			foreach ($results as $key => $database) {
				print($database['Database'] . "\n");
			}
			
			pause();
			$run_command = 1;
			break;
		case 'e': // Explain
			$counter = 1;
			$input   = read_stdin("Thread ID to explain: ");

			if (array_key_exists($input, $thread_data)) {
				system('clear');

				print($CYAN . "Thread ID: $RESET$input\n");
				print($CYAN . "User:      $RESET" . $thread_data[$input]['user'] . " @ " . $thread_data[$input]['host'] . "\n");
				print($CYAN . "Database:  $RESET" . $thread_data[$input]['db'] . "\n");
				print($CYAN . "Command:   $RESET" . $thread_data[$input]['command'] . "\n");
				print($CYAN . "State:     $RESET" . $thread_data[$input]['state'] . "\n");
				print($CYAN . "Time:      $RESET" . $thread_data[$input]['time'] . "\n\n");

				if ($thread_data[$input]['info']) {
					$connection->query("USE " . $thread_data[$input]['db']);
					$results = execute_query("EXPLAIN " . $thread_data[$input]['info'], 3);

					print("EXPLAIN " .  $thread_data[$input]['info'] . "\n\n");
					foreach ($results as $thread) {
						print "$BOLD_CYAN****************** row $counter ******************$RESET\n";
						foreach ($thread as $key => $value) {
							if (!$value) $value = "NULL";
							printf("%30s:  %s\n", "$CYAN$key$RESET", $value);
						}
						$counter++;
					}
				} else {
					print("No running query!\n");
				}
				pause();
			} else {
				print($RED . "Invalid Thread ID!$RESET");
				sleep(1);
			}

			$run_command = 1;
			break;
		case 'h': // Filter by host/IP
			$input = read_stdin("Host/IP to filter by: ");
			$config['host_filter'] = $input;

			$run_command = 1;
			break;
		case 'H': // Hide/Show headers
			if ($config['header']) {
				$config['header'] = 0;
			} else {
				$config['header'] = 1;
			}

			$run_command = 1;
			break;
		case 'i': // Hide/Show sleeping threads
			if ($config['show_idle']) {
				$config['show_idle'] = 0;
			} else {
				$config['show_idle'] = 1;
			}

			$run_command = 1;
			break;
		case 'k': // Kill thread by ID
			$input = read_stdin("Kill Thread ID: ");

			if (isset($thread_data[$input])) {
				execute_query("KILL $input", 0);
			} else {
				print($RED . "Invalid Thread ID!$RESET");
				sleep(1);
			}

			$run_command = 1;
			break;
		case 'K': // Kill by username, host, or time range
			$input = read_stdin("Kill by username/host/time range (u/h/t): ");

			if ($input == 'u') { // Kill by username
				$user  = read_stdin("Username: ");
				$found = 0;

				foreach ($thread_data as $id => $thread) {
					if ($thread['user'] == $user) {
						execute_query("KILL $id", 0);
						$found = 1;
					}
				}
				if (!$found) {
					print($RED . "No threads were killed with that username!$RESET");
					sleep(2);
				}
			} else if ($input == 'h') { // Kill by host/IP
				$host  = read_stdin("Host/IP: ");
				$found = 0;

				foreach ($thread_data as $id => $thread) {
					if ($thread['host'] == $host) {
						execute_query("KILL $id", 0);
						$found = 1;
					}
				}
				if (!$found) {
					print($RED . "No threads were killed with that host/IP!$RESET");
					sleep(2);
				}
			} else if ($input == 't') { // Kill by time range
				$time  = read_stdin("Time range (ex. 10-20): ");
				$found = 0;
				$range = explode('-', $time);

				if (sizeof($range) == 2) {
					if ($range[0] > $range[1]) {
						print($RED . "Invalid time range! First number can't be greater than the second$RESET");
						sleep(2);
					} else {
						foreach ($thread_data as $id => $thread) {
							if ($thread['time'] >= $range[0] && $thread['time'] <= $range[1]) {
								execute_query("KILL $id", 0);
								$found = 1;
							}
						}
						if (!$found) {
							print($RED . "No threads were killed with that time range!$RESET");
							sleep(2);
						}
					}
				} else {
					print($RED . "Invalid time range!$RESET");
					sleep(1);
				}
			} else {
				print($RED . "Invalid input!$RESET");
				sleep(1);
			}

			$run_command = 1;
			break;
		case 'o': // Sort by lowest/highest time for query
			if ($config['reverse_sort']) {
				$config['reverse_sort'] = 0;
			} else {
				$config['reverse_sort'] = 1;
			}

			$run_command = 1;
			break;
		case 'p': // Pause
			pause();

			$run_command = 1;
			break;
		case 'q': // Quit!
			exit($BOLD_CYAN . "\nGoodbye!$RESET\n");
		case 'r': // Resolve IPs to hostnames
			if ($config['resolve_ip']) {
				$config['resolve_ip'] = 0;
			} else {
				$config['resolve_ip'] = 1;
			}

			$run_command = 1;
			break;
		case 'R': // Reset MySQL status counters via FLUSH STATUS
			$input = read_stdin("Are you sure you want to run FLUSH STATUS? (y/n): ");

			if ($input == 'y') {
				execute_query("FLUSH STATUS", 0);
				print($CYAN . "MySQL status counters have been reset!$RESET");
				sleep(2);
			}

			$run_command = 1;
			break;
		case 's': // Seconds of delay
			$input = read_stdin("Seconds of delay: ");
			if (is_numeric($input)) {
				$config['delay'] = $input;
			} else {
				print($RED . "Input must be numeric!$RESET");
				sleep(1);
			}

			$run_command = 1;
			break;
		case 't': // Filter by time
			$input = read_stdin("Minimum time to display in seconds: ");

			if (is_numeric($input)) {
				$config['time_filter'] = $input;
			} else {
				print($RED . "Input must be numeric!$RESET");
				sleep(1);
			}

			$run_command = 1;
			break;
		case 'u': // Filter by user
			$input = read_stdin("User to filter by: ");
			$config['user_filter'] = $input;

			$run_command = 1;
			break;
		case 'v': // Display some important variables
			system('clear');

			$variables    = execute_query('SHOW GLOBAL VARIABLES', 1);
			$special_list = array('binlog_format', 'character_set_server', 'collation_server', 'innodb_checksum_algorithm', 
							  'innodb_flush_method', 'innodb_file_format','innodb_file_format_max', 'innodb_file_per_table', 
							  'innodb_flush_log_at_trx_commit', 'innodb_open_files','interactive_timeout', 'log_bin', 
							  'log_queries_not_using_indexes','log_slave_updates', 'log_warnings', 'long_query_time', 
							  'max_connect_errors', 'max_connections', 'old_passwords', 'open_files_limit', 'port',
							  'query_cache_size', 'query_cache_type', 'read_only', 'secure_auth', 'server_id', 
							  'skip_name_resolve', 'slow_query_log','table_definition_cache', 'table_open_cache', 
							  'thread_cache_size', 'wait_timeout');

			print($BOLD . "MySQL variables for $BOLD_CYAN" . $config['server'] . "$RESET$BOLD at a glance$RESET\n\n");
			foreach ($special_list as $variable) {
				if (isset($variables[$variable])) {
					printf("%-31s %s", "$variable:", $CYAN . $variables[$variable] . "$RESET\n");
				}
			}

			pause();
			$run_command = 1;
			break;
	}

	// Sleep and return 1 if a command was run to reset the keypress loop
	usleep($delay_microseconds);
	return $run_command;
}

function read_stdin($prompt) {
	global $CYAN, $RESET;

	print("$CYAN$prompt$RESET");
	system('stty echo'); //  Input text will be blank without this...
	return stream_get_line(STDIN, 1024, PHP_EOL);
}

function pause() {
	global $CYAN, $RESET;

	print($CYAN. "\nPaused! Press any key to resume.$RESET");
	
	readline_callback_handler_install('', function() { });
	while (1) {
		$r = array(STDIN);
		$w = NULL;
		$e = NULL;
		$n = stream_select($r, $w, $e, 0);
		if ($n && in_array(STDIN, $r)) {
			$c = stream_get_contents(STDIN, 1);
			break;
		}
		
		usleep(100000); // Sleep 100 milliseconds so it doesn't max out CPU
	}
}

function execute_query($query, $type) {
	global $connection, $RED, $ansi_chars;

	$results = array();
	$data    = $connection->query($query);
	
	if ($data === false) {
		print($ansi_chars['SHOW_CURSOR']);
		trigger_error($RED . 'SQL: ' . $query . ' - Error: ' . $connection->error, E_USER_ERROR);
	} else {
		if ($type) $data->data_seek(0);
		if ($type == 1) {
			while ($row = $data->fetch_assoc()){
				$results[$row['Variable_name']] = $row['Value'];
			}
		} else if ($type == 2) {
			$results = $data->fetch_all(MYSQLI_ASSOC);
			if ($results) $results = call_user_func_array('array_merge', $results); // Flatten out the array
		} else if ($type == 3) {
			$results = $data->fetch_all(MYSQLI_ASSOC);
		}
	}

	return $results;
}

function helpme($command) {
	global $BOLD, $CYAN, $BOLD_CYAN, $RESET, $UNDERLINE, $YELLOW, $version, $MAGENTA;

	system('clear');
	if ($command == '--help') {
		print($BOLD . "Below are the available parameters for$BOLD_CYAN coptop $version: $RESET\n");
		print("\t$UNDERLINE" . "Login$RESET\n");
		print($CYAN . "\t-u        \$user  $RESET(will check my.cnf client section for username field)\n");
		print($CYAN . "\t-p        \$pass  $RESET(will check my.cnf client section for password field)\n");
		print($CYAN . "\t-h        \$host$RESET\n");
		print($CYAN . "\t-P        \$port$RESET  (port of server      - default: 3306)\n");

		print("\n\t$UNDERLINE" . "Options$RESET\n");
		print($CYAN . "\t--ansi    0/1    $RESET(ansi refresh        - default: off)\n");
		print($CYAN . "\t--delay   \$delay $RESET(delay in seconds    - default: 1)\n");
		print($CYAN . "\t--header  0/1    $RESET(show header         - default: on)\n");
		print($CYAN . "\t--idle    0/1    $RESET(show idle threads   - default: off)\n");
		print($CYAN . "\t--resolve 0/1    $RESET(resolve ips to host - default: on)\n");
		print($CYAN . "\t--sort    0/1    $RESET(reverse sort        - default: on)\n");
		print($CYAN . "\t--prompt         $RESET(prompts for password; text is invisible)\n");

		exit;
	} else if ($command == '?') {
		print($BOLD_CYAN . "coptop $version$RESET$BOLD by Charles Thompson <" . $YELLOW . "01charles.t@gmail.com$RESET$BOLD>$RESET\n\n");
		printf("$CYAN%17s $CYAN%12s", $UNDERLINE . "Command$RESET", $UNDERLINE . "Description$RESET\n");
		printf("$BOLD%-9s$RESET %s", "     ?", "Help section\n");
		printf("$BOLD%-9s$RESET %s", "     c", "Clear all filters\n");
		printf("$BOLD%-9s$RESET %s", "     d", "Filter by database\n");
		printf("$BOLD%-9s$RESET %s", "     D", "Display available databases\n");
		printf("$BOLD%-9s$RESET %s", "     e", "Explain query/show information of a thread ID\n");
		printf("$BOLD%-9s$RESET %s", "     h", "Filter by host/IP\n");
		printf("$BOLD%-9s$RESET %s", "     H", "Hide/show stats header\n");
		printf("$BOLD%-9s$RESET %s", "     i", "Hide/show idle threads\n");
		printf("$BOLD%-9s$RESET %s", "     k", "Kill thread by ID\n");
		printf("$BOLD%-9s$RESET %s", "     K", "Kill threads by username, host, or time range\n");
		printf("$BOLD%-9s$RESET %s", "     o", "Reverse sort order\n");
		printf("$BOLD%-9s$RESET %s", "     p", "Pause screen\n");
		printf("$BOLD%-9s$RESET %s", "     q", "Quit\n");
		printf("$BOLD%-9s$RESET %s", "     r", "Resolve IPs to hostnames and vice versa\n");
		printf("$BOLD%-9s$RESET %s", "     R", "Reset MySQL status counters via FLUSH STATUS\n");
		printf("$BOLD%-9s$RESET %s", "     s", "Set delay in seconds\n");
		printf("$BOLD%-9s$RESET %s", "     t", "Filter by minimum time\n");
		printf("$BOLD%-9s$RESET %s", "     u", "Filter by user\n");
		printf("$BOLD%-9s$RESET %s", "     v", "Display some important variables\n");

		pause();
	}
}
